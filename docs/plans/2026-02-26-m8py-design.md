# m8-py Design Document

## Overview

A Python library for reading, writing, and composing Dirtywave M8 tracker files. Covers all four M8 file types (`.m8s`, `.m8i`, `.m8t`, `.m8n`) with full v4.1 support and backward-compatible reading of older firmware versions.

## Design Decisions

| Decision | Choice |
|----------|--------|
| Target firmware | v4.1 (latest) with v1-v3 read compatibility |
| First milestone | Format layer + full composition API |
| Reference implementations | Rust (m8-files) for format accuracy, JS (m8-js) for API design |
| Python patterns | `@dataclass` with `from_reader()`/`write()` methods |
| Package structure | Three layers: `format/`, `models/`, `compose/` |
| Version handling | Write v4.1 only, read any version (lossy upgrade documented) |
| Composition API | Imperative builder + declarative API, both available |
| Note input | String notation, MIDI integers, and named helpers — all accepted |
| Resource allocation | Auto-allocator with opt-in deduplication and manual pin override |
| Sample handling | Full SD card directory export with sample copying |
| LLM integration | Deferred — not in scope for v1 |
| Testing | Round-trip fixtures + unit tests + Hypothesis property tests |
| Dependencies | Zero runtime deps (stdlib only). pytest + hypothesis for tests |
| Thread safety | Not thread-safe. Document this explicitly. |

## Architecture

```
m8py/
  format/          # Binary format layer
    reader.py      # Sequential byte reader (cursor-based)
    writer.py      # Sequential byte writer
    offsets.py     # Version-specific byte offset tables (v1 through v4.1)
    constants.py   # Sentinel values, magic bytes, enums
    errors.py      # Exception hierarchy

  models/          # Dataclass layer
    song.py        # Song, SongStep, MixerSettings, MIDISettings, EffectsSettings
    chain.py       # Chain, ChainStep
    phrase.py      # Phrase, PhraseStep, FX
    instrument.py  # BaseInstrument + 7 subtypes
    table.py       # Table, TableStep
    groove.py      # Groove
    scale.py       # Scale, NoteInterval
    theme.py       # Theme, RGB
    midi.py        # MIDIMapping, MIDICC
    eq.py          # EQ, EQBand
    modulators.py  # AHD, ADSR, DrumEnv, LFO, TrigEnv, TrackingEnv
    synth_params.py # FilterParams, MixerParams, common synth fields
    version.py     # M8Version, M8FileType, VersionCapabilities

  compose/         # Composition layer
    builder.py     # Imperative SongBuilder API
    declarative.py # High-level descriptive API
    allocator.py   # Slot allocation with opt-in deduplication
    notation.py    # Note parsing (string, MIDI int, named helpers)
    samples.py     # Sample path management and SD card export

  io.py            # Top-level load/save entry points
  validate.py      # Validation for all model types

tests/
  fixtures/           # Real M8 files from various firmware versions
  test_format/        # Reader/writer unit tests
  test_models/        # Per-structure from_reader/write tests
  test_compose/       # Builder, declarative, allocator, notation tests
  test_roundtrip.py   # End-to-end load/save/compare
  test_properties.py  # Hypothesis-based generative tests
```

Each layer depends only on the one below: `compose/` -> `models/` -> `format/`.

## Error Handling

### Exception Hierarchy (`format/errors.py`)

```python
class M8Error(Exception):
    """Base exception for all m8py errors."""

class M8ParseError(M8Error):
    """Raised when binary data cannot be parsed."""
    # Includes: bad magic bytes, truncated file, unknown instrument type byte,
    # non-UTF-8/non-ASCII string data, unexpected EOF

class M8VersionError(M8Error):
    """Raised for unsupported or unrecognized version numbers."""

class M8ValidationError(M8Error):
    """Raised when a model violates M8 constraints."""
    # Includes: parameter out of range, invalid note value,
    # reference to unallocated slot

class M8ResourceExhaustedError(M8Error):
    """Raised when a slot pool is full (e.g. 255 phrases used)."""
    # Raised at allocation time, not at write time
```

### Error Policy

- **Strict by default**: raise on any anomaly during parsing or writing
- **Reader bounds checking**: `M8FileReader.read()` raises `M8ParseError` if cursor exceeds data length
- **Header validation**: `load()` validates magic bytes and file type before dispatching
- **Unknown instrument types**: raise `M8ParseError` with the byte value and offset
- **Truncated files**: raise `M8ParseError` with expected vs actual size
- **Validation on save**: `save()` calls `validate()` before writing. Pass `validate=False` to bypass.

## Format Layer

### reader.py

Cursor-based sequential byte reader with bounds checking:

```python
class M8FileReader:
    def __init__(self, data: bytes)
    def read(self) -> int              # Read one byte, advance cursor. Raises M8ParseError on EOF.
    def read_bytes(self, n) -> bytes   # Read n bytes. Raises M8ParseError if insufficient data.
    def read_str(self, n) -> str       # Read fixed-length ASCII string (see String Encoding below)
    def read_float_le(self) -> float   # Read 4-byte LE float (tempo)
    def read_bool(self) -> bool        # Read byte as boolean
    def read_u16_le(self) -> int       # Read 2-byte LE unsigned int
    def position(self) -> int          # Current cursor offset
    def seek(self, offset)             # Jump to absolute position. Raises if out of bounds.
    def skip(self, n)                  # Advance cursor n bytes
    def remaining(self) -> int         # Bytes left to read
    def expect_consumed(self, n, start) # Assert exactly n bytes consumed since start. Raises M8ParseError.
```

### writer.py

Mirror of the reader with size tracking:

```python
class M8FileWriter:
    def __init__(self)
    def write(self, byte: int)
    def write_bytes(self, data: bytes)
    def write_str(self, s: str, length: int)  # ASCII, pad with 0x00 (see String Encoding)
    def write_float_le(self, value: float)
    def write_bool(self, value: bool)
    def write_u16_le(self, value: int)
    def pad(self, n, value=0x00)
    def position(self) -> int          # Current write offset
    def expect_written(self, n, start) # Assert exactly n bytes written since start. Raises M8ParseError.
    def to_bytes(self) -> bytes
```

### String Encoding

- **Encoding**: ASCII only. Non-ASCII bytes raise `M8ParseError` during read.
- **Read termination**: strings are terminated by the first `0x00` or `0xFF` byte. The full `n` bytes are always consumed from the reader regardless of terminator position.
- **Write behavior**: strings are encoded as ASCII, truncated to `length - 1` if too long (preserving null terminator), padded with `0x00` to fill remaining space.
- **Round-trip note**: an empty field filled with `0xFF` reads as `""`. When written back, an empty string writes as all `0x00`. This is acceptable — the M8 treats both as empty.

### offsets.py

Version-specific offset tables for all supported versions:

```python
@dataclass
class SongOffsets:
    groove: int
    song: int
    phrases: int
    chains: int
    table: int
    instruments: int
    effect_settings: int
    midi_mapping: int
    scale: int | None       # None for pre-v2.5
    eq: int | None          # None for pre-v4

# Offset tables derived from m8-files (Rust) source
V1_OFFSETS = SongOffsets(...)   # Firmware 1.x
V2_OFFSETS = SongOffsets(...)   # Firmware 2.0-2.4
V25_OFFSETS = SongOffsets(...)  # Firmware 2.5-2.7 (scales added)
V3_OFFSETS = SongOffsets(...)   # Firmware 3.x (new modulators, HyperSynth, External)
V4_OFFSETS = SongOffsets(
    groove=0xEE, song=0x2EE, phrases=0xAEE,
    chains=0x9A5E, table=0xBA3E, instruments=0x13A3E,
    effect_settings=0x1A5C1, midi_mapping=0x1A5FE,
    scale=0x1AA7E, eq=0x1AD5E,
)

def offsets_for_version(version: M8Version) -> SongOffsets:
    """Return the correct offset table for a given firmware version."""
```

### constants.py

Magic bytes, sentinel values, and enums:

- File header: `M8VERSION` (9 bytes) + padding + version + type = 14 bytes
- File types: `Song=0x00, Instrument=0x10, Theme=0x20, Scale=0x30`
- Empty sentinel: `0xFF` universally
- Instrument kinds: `WAVSYNTH=0, MACROSYNTH=1, SAMPLER=2, MIDIOUT=3, FMSYNTH=4, HYPERSYNTH=5, EXTERNAL=6, NONE=0xFF`
- FX commands: sequencer (0x00-0x1A), mixer/FX (0x1B-0x46), instrument-specific (0x80+)
- Note encoding: `0x00-0x7F` = note, `0x80+` = note off, `0xFF` = empty
- Instrument memory size: `INSTRUMENT_SIZE = 215` bytes (constant across all types and versions)

## Version Handling

### Version Capabilities (`models/version.py`)

Centralized version knowledge — model code checks capabilities, not raw version numbers:

```python
@dataclass
class M8Version:
    major: int
    minor: int
    patch: int

    @property
    def caps(self) -> 'VersionCapabilities':
        return VersionCapabilities.from_version(self)

@dataclass(frozen=True)
class VersionCapabilities:
    has_scales: bool          # v2.5+
    has_new_modulators: bool  # v3+ (4 generic modulators replacing 2 AHD + 2 LFO)
    has_hypersynth: bool      # v3+
    has_external: bool        # v3+
    has_eq: bool              # v4+
    has_expanded_eq: bool     # v4.1+ (128 instrument EQs vs 32)
    lfo_count: int            # 1 pre-v2.6, 2 in v2.6+, N/A for v3+ (modulators)
    phrase_step_size: int     # Bytes per phrase step (varies by version)
    table_step_size: int      # Bytes per table step

    @staticmethod
    def from_version(v: M8Version) -> 'VersionCapabilities': ...
```

### Read-Any, Write-v4.1 Semantics

- **Reading**: the parser checks `version.caps` to determine field layouts, section presence, and modulator format. All versions from 1.x through 4.1 are supported.
- **Writing**: `save()` always writes v4.1 format. The version field on the Song object is overwritten to 4.1.0.
- **Lossy upgrade**: when reading a pre-v3 file, the 2-AHD + 2-LFO modulator layout is converted to the v3+ 4-modulator format. This is a one-way conversion. When reading a pre-v2.5 file, scales are initialized to defaults. When reading pre-v4, EQs are initialized to defaults.
- **Warning on lossy load**: `load()` returns the parsed object. If lossy conversion occurred, the object's `_upgrade_warnings: list[str]` field is populated (empty list if no conversion needed). The caller can inspect this.

## Models Layer

Every M8 structure is a `@dataclass` with `from_reader(reader, version)` and `write(self, writer)`. Version-conditional logic uses `version.caps` for branching.

### Fixed-Size Byte Enforcement

Structures with fixed byte sizes in the binary format use reader/writer assertions:

```python
@dataclass
class BaseInstrument:
    ...
    @staticmethod
    def from_reader(reader: M8FileReader, version: M8Version) -> 'BaseInstrument':
        start = reader.position()
        kind = InstrumentKind(reader.read())
        # ... dispatch and parse subtype ...
        reader.expect_consumed(INSTRUMENT_SIZE, start)  # Raises M8ParseError if != 215 bytes
        return instrument

    def write(self, writer: M8FileWriter):
        start = writer.position()
        # ... serialize fields ...
        writer.expect_written(INSTRUMENT_SIZE, start)  # Raises M8ParseError if != 215 bytes
```

This pattern applies to instruments (215 bytes), phrase steps, table steps, chains, and any other fixed-size structure.

### Song

```python
@dataclass
class Song:
    version: M8Version
    name: str = ""
    directory: str = ""
    tempo: float = 120.0
    transpose: int = 0
    quantize: int = 0
    key: int = 0
    midi_settings: MIDISettings
    mixer_settings: MixerSettings
    effects_settings: EffectsSettings
    steps: list[SongStep]          # 256 rows
    chains: list[Chain]            # 255 slots
    phrases: list[Phrase]          # 255 slots
    instruments: list[Instrument]  # 128 slots
    tables: list[Table]            # 256 slots
    grooves: list[Groove]          # 32 slots
    midi_mappings: list[MIDIMapping]  # 128 slots
    scales: list[Scale]            # 16 slots (v2.5+, defaults for older)
    eqs: list[EQ]                  # v4+ (defaults for older)
    _upgrade_warnings: list[str] = field(default_factory=list)
```

### Phrase Steps

```python
@dataclass
class PhraseStep:
    note: int = 0xFF       # 0xFF = empty, 0x00-0x7F = note, 0x80+ = note off
    velocity: int = 0xFF
    instrument: int = 0xFF
    fx1: FX = field(default_factory=FX)
    fx2: FX = field(default_factory=FX)
    fx3: FX = field(default_factory=FX)

@dataclass
class FX:
    command: int = 0xFF    # 0xFF = empty
    value: int = 0x00
```

### Instruments

Polymorphic via type byte dispatch:

```python
@dataclass
class BaseInstrument:
    kind: InstrumentKind
    name: str = ""
    transpose: bool = True
    table_tick: int = 1
    volume: int = 0
    pitch: int = 0
    fine_tune: int = 128
    filter: FilterParams
    mixer: MixerParams
    modulators: list[Modulator]  # 4 slots

    @staticmethod
    def from_reader(reader, version) -> 'BaseInstrument':
        start = reader.position()
        kind_byte = reader.read()
        if kind_byte == 0xFF:
            reader.seek(start + INSTRUMENT_SIZE)
            return EmptyInstrument()
        try:
            kind = InstrumentKind(kind_byte)
        except ValueError:
            raise M8ParseError(f"Unknown instrument type 0x{kind_byte:02X} at offset {start}")
        # Dispatch to subclass...
        reader.expect_consumed(INSTRUMENT_SIZE, start)
        return instrument
```

Seven concrete subtypes: `Wavsynth`, `Macrosynth`, `Sampler`, `MIDIOut`, `FMSynth`, `HyperSynth`, `External`, plus `EmptyInstrument` for `0xFF` slots.

Each instrument occupies exactly 215 bytes regardless of type. This is enforced by `expect_consumed`/`expect_written` assertions.

### Theme

Standalone `.m8t` files share the standard 14-byte M8 header (with file type `0x20`), followed by 39 bytes of color data:

```python
@dataclass
class Theme:
    version: M8Version
    background: RGB = field(default_factory=lambda: RGB(0, 0, 0))
    text_empty: RGB = ...
    text_info: RGB = ...
    text_default: RGB = ...
    text_value: RGB = ...
    text_title: RGB = ...
    play_marker: RGB = ...
    cursor: RGB = ...
    selection: RGB = ...
    scope_slider: RGB = ...
    meter_low: RGB = ...
    meter_mid: RGB = ...
    meter_peak: RGB = ...

@dataclass
class RGB:
    r: int = 0
    g: int = 0
    b: int = 0
```

Theme is a standalone file type only — not embedded in songs.

### Scale

Standalone `.m8n` files share the 14-byte header (file type `0x30`), followed by 42 bytes. The same `Scale` dataclass is used for both standalone files and song-embedded scales (16 per song):

```python
@dataclass
class Scale:
    name: str = ""                        # 16 bytes
    note_enable: int = 0xFFF              # u16 bitmap, bit per note C-B
    note_offsets: list[NoteInterval] = ... # 12 intervals

@dataclass
class NoteInterval:
    semitone: int = 0
    cents: int = 0
```

### EQ

The EQ count depends on firmware sub-version:
- **v4.0**: 32 instrument EQs + 3 effect EQs + 1 global EQ = 36 total
- **v4.1+**: 128 instrument EQs + 3 effect EQs + 1 global EQ = 132 total

Determined by `version.caps.has_expanded_eq`. Each EQ has 3 bands:

```python
@dataclass
class EQ:
    low: EQBand = field(default_factory=EQBand)
    mid: EQBand = field(default_factory=EQBand)
    high: EQBand = field(default_factory=EQBand)

@dataclass
class EQBand:
    mode_type: int = 0
    freq_fine: int = 0
    freq: int = 0
    level_fine: int = 0
    level: int = 0
    q: int = 0
```

### Modulators (v3+ format)

```python
@dataclass
class Modulator:
    type: ModulatorType  # AHD, ADSR, DrumEnv, LFO, TrigEnv, TrackingEnv
    destination: int
    amount: int
    # Type-specific fields...
```

Pre-v3: 2 AHD envelopes + 2 LFOs (different layout). On read, converted to 4 v3-style modulators (lossy — original layout not preserved). Flagged in `_upgrade_warnings`.

### Default Initialization

Every dataclass initializes to M8's empty state (0xFF sentinels, zeroed parameters). `Song()` produces a valid empty song file for creation from scratch.

### Equality and Hashing

Model dataclasses use the default `@dataclass(eq=True)` for structural equality. They are **not** frozen (composition requires mutability).

For the allocator's deduplication, equality comparison uses **serialized bytes** rather than Python structural equality — this avoids pitfalls with floating-point comparison and nested mutable lists:

```python
def content_hash(obj) -> bytes:
    """Serialize to bytes and hash. Used by SlotAllocator for dedup."""
    writer = M8FileWriter()
    obj.write(writer)
    return hashlib.sha256(writer.to_bytes()).digest()
```

## Validation (`validate.py`)

```python
def validate(obj: Song | BaseInstrument | Theme | Scale) -> list[ValidationIssue]:
    """Check all M8 constraints. Returns list of issues (empty = valid)."""

@dataclass
class ValidationIssue:
    severity: Literal["error", "warning"]
    path: str      # e.g. "instruments[3].filter.cutoff"
    message: str   # e.g. "value 300 exceeds maximum 255"
```

Checks include:
- **Parameter ranges**: all byte fields in 0-255, note values in valid ranges
- **Slot references**: chain/phrase/instrument references point to non-empty slots
- **Tempo range**: within M8's supported BPM range
- **String lengths**: names fit in their fixed-size fields
- **FX validity**: command bytes are known values
- **Sample paths**: Sampler instruments have non-empty paths (warning, not error)

`save()` calls `validate()` by default and raises `M8ValidationError` if any errors found. Warnings are logged. Pass `validate=False` to skip.

## Composition Layer

### notation.py

Three input formats, all normalize to MIDI int (0-127):

```python
normalize_note("C4")   # -> 60 (string)
normalize_note(60)     # -> 60 (MIDI int)
C4                     # -> 60 (named constant)
```

String mini-language for phrase patterns (MVP: notes only):

```python
parse_pattern("C4 E4 G4 --- | C4 E4 G4 B4")
# Notes: "C4", "F#3", "Bb5"
# Empty: "---" or "."
# Note off: "OFF"
# Velocity: "C4@7F" (hex)
# Bar separator: "|" (cosmetic, ignored)
```

FX inline syntax (`"C4[ARP:03,DEL:02]"`) is deferred to post-MVP. For now, FX are set explicitly via the builder API or by constructing `PhraseStep` objects directly.

### allocator.py

```python
class SlotAllocator:
    """Tracks used slots. Raises M8ResourceExhaustedError when full."""

    def __init__(self, deduplicate: bool = False):
        """
        deduplicate=False (default): every alloc gets a unique slot.
        deduplicate=True: identical structures (by content hash) share a slot.
        """

    def alloc_phrase(self, phrase: Phrase) -> int:
        # If deduplicate=True, check content_hash against existing.
        # If match found, return existing slot index.
        # Otherwise assign next free slot.
        # Raises M8ResourceExhaustedError if all 255 phrase slots used.

    def alloc_chain(self, chain: Chain) -> int: ...
    def alloc_instrument(self, instrument: BaseInstrument) -> int: ...
    def alloc_table(self, table: Table) -> int: ...
    def alloc_groove(self, groove: Groove) -> int: ...

    # Manual pinning for explicit slot control
    def pin_phrase(self, slot: int, phrase: Phrase): ...
    def pin_instrument(self, slot: int, instrument: BaseInstrument): ...

    # Introspection
    def phrases_used(self) -> int: ...
    def phrases_remaining(self) -> int: ...
    # (same for chains, instruments, tables, grooves)
```

**Deduplication is opt-in** (`deduplicate=False` by default). When disabled, every allocation gets its own slot — mutations never leak to other tracks. When enabled, the caller understands that shared slots mean shared data.

The declarative API enables deduplication by default (since it compiles patterns into phrases and benefits from reuse), but documents this clearly.

### builder.py

Imperative API with full M8-level control. All methods return `self` for chaining. Slot indices are retrieved via separate accessors:

```python
class SongBuilder:
    def __init__(self, tempo=120.0, name="", deduplicate=False):
        self._song = Song(version=M8Version(4,1,0))
        self._allocator = SlotAllocator(deduplicate=deduplicate)
        self._last_slot: int = -1

    def set_tempo(self, bpm: float) -> 'SongBuilder': ...
    def set_key(self, key: int) -> 'SongBuilder': ...

    def add_instrument(self, instrument: BaseInstrument, slot=None) -> 'SongBuilder':
        # Allocates or pins, stores index in self._last_slot
    def add_phrase(self, steps, slot=None) -> 'SongBuilder':
        # Accepts list[PhraseStep] or pattern string
    def add_chain(self, phrase_refs, slot=None) -> 'SongBuilder':
        # phrase_refs: list of (phrase_index, transpose) tuples
    def set_song_step(self, row: int, track: int, chain: int) -> 'SongBuilder': ...

    @property
    def last_slot(self) -> int:
        """Slot index from the most recent add_* call."""
        return self._last_slot

    def build(self) -> Song:
        """Finalize and validate the song."""
```

Usage:
```python
b = SongBuilder(tempo=128, name="DEMO")
b.add_instrument(macrosynth(shape="SAW"))
inst_slot = b.last_slot
b.add_phrase("C4 E4 G4 .")
phrase_slot = b.last_slot
b.add_chain([(phrase_slot, 0)])
chain_slot = b.last_slot
b.set_song_step(0, 0, chain_slot)
song = b.build()
```

### declarative.py

High-level musical description. Each pattern string becomes one or more phrases (auto-split if >16 steps), chained together, and placed in the song grid:

```python
def compose(
    tempo: float = 120.0,
    name: str = "",
    key: str = "C",
    scale: str = "Chromatic",
    tracks: list[TrackDef] = [],
) -> Song:
    """Compile a high-level song description into a Song.
    Uses SlotAllocator with deduplicate=True by default."""

@dataclass
class TrackDef:
    instrument: BaseInstrument
    patterns: list[str | list[PhraseStep]]
    groove: list[int] | None = None
```

**Pattern-to-song mapping**:
- Each string in `patterns` is parsed via `parse_pattern()` into a list of `PhraseStep` objects.
- If the result exceeds 16 steps, it is split into multiple 16-step phrases.
- Those phrases are grouped into a chain (max 16 phrases per chain, split further if needed).
- Each chain is placed at the next available song row for the track.
- All tracks' patterns are aligned to the same song rows.
- Patterns are **copied** into the allocator — the `TrackDef` input is not referenced after compilation. Mutations to the returned `Song` object do not affect other tracks (even with deduplication, the dedup operates on the immutable compiled output, not live references).

### samples.py

```python
def export_to_sdcard(
    song: Song,
    output_dir: Path,
    sample_sources: dict[str, Path] = {},
    dry_run: bool = False,
) -> ExportResult:
    """Export a song file plus organized sample directory.

    Args:
        song: The Song to export.
        output_dir: Root directory (becomes the SD card root).
        sample_sources: Maps M8 sample paths (as stored in Sampler instruments)
                        to local filesystem paths where the actual audio files live.
        dry_run: If True, validate and return the plan without writing files.

    Returns:
        ExportResult with file manifest and any warnings.

    Raises:
        M8ValidationError: If referenced samples are missing from sample_sources.
    """

@dataclass
class ExportResult:
    song_path: Path                      # Where the .m8s was written
    samples_copied: list[tuple[str, Path]]  # (m8_path, dest_path) pairs
    warnings: list[str]                  # Non-fatal issues
```

**Sample path conventions**:
- M8 Sampler instruments store paths relative to the SD card root (e.g., `/Samples/kick.wav`).
- `export_to_sdcard` creates the directory structure under `output_dir` and copies sample files into their expected locations.
- Missing samples (referenced in instruments but not in `sample_sources`) raise `M8ValidationError`. Use `dry_run=True` to check before writing.
- Audio format validation is out of scope — the library copies files as-is. The user is responsible for providing M8-compatible WAV files.

## I/O

```python
def load(path: str | Path) -> Song | BaseInstrument | Theme | Scale:
    """Load any M8 file. Detects type from header."""

def load_song(path: str | Path) -> Song:
    """Load an .m8s file. Raises M8ParseError if file is not a song."""

def load_instrument(path: str | Path) -> BaseInstrument:
    """Load an .m8i file. Raises M8ParseError if file is not an instrument."""

def load_theme(path: str | Path) -> Theme:
    """Load an .m8t file. Raises M8ParseError if file is not a theme."""

def load_scale(path: str | Path) -> Scale:
    """Load an .m8n file. Raises M8ParseError if file is not a scale."""

def save(obj: Song | BaseInstrument | Theme | Scale, path: str | Path, validate: bool = True):
    """Write an M8 object to file.

    Args:
        validate: If True (default), run validation before writing.
                  Raises M8ValidationError on errors. Warnings are logged.
    """
```

## Testing Strategy

### Round-Trip Fixture Tests

Collect real `.m8s`/`.m8i`/`.m8t`/`.m8n` files across firmware versions (v1.x, v2.x, v3.x, v4.0, v4.1). For each:
- Load the file
- Serialize back to bytes
- **For v4.1 files**: assert byte-for-byte equality
- **For older files**: assert structural equality after load (bytes will differ due to v4.1 upgrade on write)

### Unit Tests Per Structure

Handcrafted byte sequences for each dataclass. Specific coverage for:
- Version-conditional paths (v2 vs v3 modulator format, v4 EQ presence)
- Instrument type dispatch (all 7 types + empty)
- `expect_consumed`/`expect_written` assertions fire correctly
- Error cases: truncated data, unknown type bytes, out-of-range values

### Hypothesis Property Tests

Concrete invariants:
- **Roundtrip identity**: `from_reader(to_bytes(x)) == x` for all model types
- **Byte size invariants**: instruments always serialize to exactly 215 bytes
- **Value constraints**: all byte fields produce values in 0-255
- **Sentinel preservation**: empty slots round-trip as empty
- **Allocator limits**: generating >255 unique phrases raises `M8ResourceExhaustedError`

### Fuzz Testing

Feed random/malformed bytes to `load()` and assert it either returns a valid object or raises `M8ParseError` — never crashes, never hangs.

## Key Format Details

### File Header (14 bytes, all types)

| Offset | Size | Field |
|--------|------|-------|
| 0x00 | 10 | `"M8VERSION"` + 0x00 padding |
| 0x0A | 1 | LSB: minor (upper nibble) + patch (lower nibble) |
| 0x0B | 1 | MSB: major (lower nibble) + file type (upper nibble) |
| 0x0C | 2 | Padding |

### Song Data Sizes

| Structure | Count | Step Size (v4) | Steps | Total |
|-----------|-------|----------------|-------|-------|
| Song steps | 256 | 8 bytes (1/track) | 1 | 2048 B |
| Grooves | 32 | 1 byte | 16 | 512 B |
| Phrases | 255 | 9 bytes | 16 | 36,720 B |
| Chains | 255 | 2 bytes | 16 | 8,160 B |
| Tables | 256 | 8 bytes | 16 | 32,768 B |
| Instruments | 128 | 215 bytes | 1 | 27,520 B |
| MIDI mappings | 128 | 7 bytes | 1 | 896 B |
| Scales | 16 | 42 bytes | 1 | 672 B |

### Instrument Type Byte Dispatch

| Byte | Type | Added |
|------|------|-------|
| 0x00 | WavSynth | v1 |
| 0x01 | MacroSynth | v1 |
| 0x02 | Sampler | v1 |
| 0x03 | MIDI Out | v1 |
| 0x04 | FM Synth | v1 |
| 0x05 | HyperSynth | v3 |
| 0x06 | External | v3 |
| 0xFF | Empty | - |

## Reference Sources

- **m8-files (Rust)**: https://github.com/AlexCharlton/m8-files — primary format reference (v1-v4.1)
- **m8-js (JavaScript)**: https://github.com/whitlockjc/m8-js — API design reference
- **m8s-kaitai-struct**: https://github.com/colonel-blimp/m8s-kaitai-struct — formal format definitions
- **ftsf Nim gist**: https://gist.github.com/ftsf/223b0fc761339b3c23dda7dd891514d9 — original reverse-engineering
